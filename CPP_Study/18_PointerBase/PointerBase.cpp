#include<iostream>
using namespace std;

// 오늘의 주제 : 포인터
void SetHp(int* hp)// 1) * 는 포인터임을 의미
{
	*hp = 100;// 2)이름 앞에 *는 워프를 하라는 의미
}


//[인자][RET][지역변수(hp 1)] [매개변수(주소)][RET][지역변수(hp 1)]
int main()
{


	int hp = 1;

	SetHp(&hp);// 주소를 넘겨줌.


	// 지금까지 사용한 방식
	// number라는 이름의 4바이트 정수 타입의 바구니를 만든다.
	// number라는 변수 스택 메모리에 할당
	// number = 1라 함은, number 바구니에 1이라는 숫자를 넣으라는 의미.
	// 따라서 스택 메모리에 있는 특정 주소(number 바구니)에 우리가 원하는 값을 넣은 셈
	// number는 비유하자면 메모리에 이름을 붙인 것( 찰떡같이 알아들어서)
	// 나쁘지 않고 편리한데, 단점은 TextRPG 원본 수정

	int number = 1;

	// TYPE* 변수이름;
	// 일단 2가지 요소
	// - TYPE
	// - *

	// 바구니는 바구니인데..
	// [주소를 저장하는 바구니다!]
	// 변수 선언할 때 * 등장했다 -> 포인터 = 주소
	// ex) 포인터라는 바구니는 4바이트(32비트) or 8바이트(64비트) 고정크기.

	int* ptr = &number;
	// 000B1836  lea   eax,[number]  : number의 주소를 eax에 넣어줘라.는 명령어 
	// lea : load effective address
	// 여기서 다른점은 lea일때, [] 가 값이 아닌 주소를 의미함.

	//000B183C  mov         eax, dword ptr[ptr]
	// ptr 이 2번 나오는데, []안에 있는게 우리가 선언한 ptr이다.


	//근데 남의 주소를 갖고 뭘 하라는거지?
	//추가 문법 ; [주소를 저장하는 바구니]가 가리키는 주소로 가서 무엇인가를 해라!
	// *변수이름 = 값

	// * 이 붙으면 포탈을 타고 순간이동 한다고 생각해보자
	// * 이 여러번 등장하니 헷갈리는데, 사용 시점에 따라서 구분해서 기억하자.
	// - 변수 선언(주소를 저장하는바구니다!)
	// - 사용할 때 (포탈 타고 순간이동)
	// 
	// 

	int value1 = *ptr;
	*ptr = 2;

	//TYPE은 왜 붙여줄까?
	// * = 포인터의 의미 = 주소를 저장하는 바구니 =  4/8바이트 고정 크기
	// 주소에 가면 뭐가 있는데?
	// ex) 결혼식 청접장에 있는 주소 = 예식장 주소
	//     명함에 있는 주소 = 회사 주소
	// * = 포인터 (주소 담는 바구니)

	// 해당 주소로 갔을때 분석하기 위해서 타입(TYPE)이 필요하다.
	//-> 주소 자체로는 불충분, 해당 주소로 가서 몇 바이트를 꺼내서 사용할 때, 정수인지 실수인지 등등 에 따라서 분석을 해야 올바르게 데이터를 인식할 수 있다.



	// 타입의 불일치
	__int64* ptr2 = (__int64*) & number;// __int64 8바이트 변수

	*ptr2 = 0x0000AABBCCDDEEFF;// AA : 2개가 1바이트임. 1바이트 = 8비트 ---> 16진수 한 자리는 4비트를 표현, 따라서 두 자리 16진수는 8비트
	// 이때 메모리 침범이 일어남. 프로그램이 이상하게 동작할 수 있다.
	// c++의 가장 무서운점은, 주소를 잘 못 실수하면, 해당 주소를 넘어서 사용할 때, 중대한 버그가 발생할 수 있다. 메모리를 덮어쓸 수 있기 때문이다.




	return 0;
	

}